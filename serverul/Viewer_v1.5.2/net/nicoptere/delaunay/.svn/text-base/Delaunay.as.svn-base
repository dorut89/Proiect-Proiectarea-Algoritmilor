package net.nicoptere.delaunay{	import flash.geom.Point;	import net.nicoptere.delaunay.DelaunayTriangle;	import net.nicoptere.delaunay.DelaunayEdge;			//Credit to Paul Bourke (pbourke@swin.edu.au) for the original Fortran 77 Program :))	//Converted to a standalone C# 2.0 library by Morten Nielsen (www.iter.dk)	//Check out: http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/	//You can use this code however you like providing the above credits remain in tact	/**	 * @author nicoptere	 * http://en.nicoptere.net/	 */	public class Delaunay		{				/**		 * performs a Delaunay triangulation on a  set of points 		 * @param points the original Vector of points		 * @return a Vector.<DelaunAyTriangle> of delaunay triangles		 * 		 */		public static function Triangulate( points:Vector.<Point> ):Vector.<DelaunayTriangle>		{			//those will be used quite everywhere so I am storing them here not to declare them x times			var i:int;			var j:int;			var nv:int = points.length;			if (nv < 3) return null;			var trimax:int = 4 * nv;									// Find the maximum and minimum vertex bounds.			// This is to allow calculation of the bounding supertriangle			var xmin:Number = points[0].x;			var ymin:Number = points[0].y;			var xmax:Number = xmin;			var ymax:Number = ymin;						var vertex:Vector.<DelaunayPoint> = new Vector.<DelaunayPoint>( nv );						for ( i = 0; i < nv; i++)			{								vertex[ i ] = new DelaunayPoint( points[i].x, points[i].y, i );								if (vertex[i].x < xmin) xmin = vertex[i].x;				if (vertex[i].x > xmax) xmax = vertex[i].x;				if (vertex[i].y < ymin) ymin = vertex[i].y;				if (vertex[i].y > ymax) ymax = vertex[i].y;			}						var dx:Number = xmax - xmin;			var dy:Number = ymax - ymin;			var dmax:Number = (dx > dy) ? dx : dy;			var xmid:Number = (xmax + xmin) * 0.5;			var ymid:Number = (ymax + ymin) * 0.5;			// Set up the supertriangle			// This is a triangle which encompasses all the sample points.			// The supertriangle coordinates are added to the end of the			// vertex list. The supertriangle is the first triangle in			// the triangle list.			vertex.push(new DelaunayPoint( (xmid - 2 * dmax), (ymid - dmax), nv + 1 ) );						vertex.push(new DelaunayPoint( xmid, (ymid + 2 * dmax), nv + 2 ) );						vertex.push(new DelaunayPoint((xmid + 2 * dmax), (ymid - dmax), nv + 3));						var triangles:Vector.<DelaunayTriangle> = new Vector.<DelaunayTriangle>();			triangles.push( new DelaunayTriangle( vertex[ nv ], vertex[ nv + 1 ], vertex[ nv + 2 ] ) ); //SuperTriangle placed at index 0						// Include each point one at a time into the existing mesh			for ( i = 0; i < nv; i++)			{								var DelaunayEdges:Vector.<DelaunayEdge> = new Vector.<DelaunayEdge>(); 				// Set up the DelaunayEdge buffer.				// If the point (vertex(i).x,vertex(i).y) lies inside the circumcircle then the				// three DelaunayEdges of that triangle are added to the DelaunayEdge buffer and the triangle is removed from list.				for ( j = 0; j < triangles.length; j++ )				{										if ( InCircle( vertex[ i ], triangles[ j ].p1, triangles[ j ].p2, triangles[ j ].p3 ) )					{						DelaunayEdges.push(new DelaunayEdge(triangles[j].p1, triangles[j].p2) );						DelaunayEdges.push(new DelaunayEdge(triangles[j].p2, triangles[j].p3) );						DelaunayEdges.push(new DelaunayEdge(triangles[j].p3, triangles[j].p1) );						triangles.splice( j,1 );						j--;					}				}				if ( i >= nv) continue; //In case we the last duplicate point we removed was the last in the array				// Remove duplicate DelaunayEdges				// Note: if all triangles are specified anticlockwise then all				// interior DelaunayEdges are opposite pointing in direction.				for ( j = DelaunayEdges.length - 2; j >= 0; j--)				{					for (var k:int = DelaunayEdges.length - 1; k >= j + 1; k--)					{						if ( DelaunayEdges[ j ].equals( DelaunayEdges[ k ] ) )						{							DelaunayEdges.splice( k, 1 );							DelaunayEdges.splice( j, 1 );							k--;							continue;						}					}				}				// Form new triangles for the current point				// Skipping over any tagged DelaunayEdges.				// All DelaunayEdges are arranged in clockwise order.				for ( j = 0; j < DelaunayEdges.length; j++)				{					if (triangles.length >= trimax )					{						//	throw new ApplicationException("Exceeded maximum DelaunayEdges");						trace("Exceeded maximum DelaunayEdges");											}					triangles.push( new DelaunayTriangle( DelaunayEdges[ j ].p1, DelaunayEdges[ j ].p2, vertex[ i ] ));				}				DelaunayEdges = null;							}						// Remove triangles with supertriangle vertices			// These are triangles which have a vertex number greater than nv			for ( i = triangles.length - 1; i >= 0; i--)			{								if ( triangles[ i ].p1.id >= nv || triangles[ i ].p2.id >= nv || triangles[ i ].p3.id >= nv)				{					triangles.splice(i, 1);				}							}			//Remove SuperTriangle vertices			/*			vertex.splice(vertex.length - 1, 1);			vertex.splice(vertex.length - 1, 1);			vertex.splice(vertex.length - 1, 1);			*/			return triangles;		}		/// <summary>		/// Returns true if the point (p) lies inside the circumcircle made up by points (p1,p2,p3)		/// </summary>		/// <remarks>		/// NOTE: A point on the DelaunayEdge is inside the circumcircle		/// </remarks>		/// <param name="p">Point to check</param>		/// <param name="p1">First point on circle</param>		/// <param name="p2">Second point on circle</param>		/// <param name="p3">Third point on circle</param>		/// <returns>true if p is inside circle</returns>		static private const Epsilon:Number = Number.MIN_VALUE;		private static function InCircle( p:DelaunayPoint, p1:DelaunayPoint, p2:DelaunayPoint, p3:DelaunayPoint ):Boolean		{			//Return TRUE if the point (xp,yp) lies inside the circumcircle			//made up by points (x1,y1) (x2,y2) (x3,y3)			//NOTE: A point on the DelaunayEdge is inside the circumcircle			if ( Math.abs( p1.y - p2.y ) < Epsilon && Math.abs( p2.y - p3.y) < Epsilon)			{				//INCIRCUM - F - Points are coincident !!				return false;			}			var m1:Number;			var m2:Number;			var mx1:Number;			var mx2:Number;			var my1:Number;			var my2:Number;			var xc:Number;			var yc:Number;									if ( Math.abs(p2.y - p1.y) < Epsilon)			{				m2 = -(p3.x - p2.x) / (p3.y - p2.y);				mx2 = (p2.x + p3.x) * 0.5;				my2 = (p2.y + p3.y) * 0.5;				//Calculate CircumCircle center (xc,yc)								xc = (p2.x + p1.x) * 0.5;				yc = m2 * (xc - mx2) + my2;			}			else if ( Math.abs(p3.y - p2.y) < Epsilon)			{				m1 = -(p2.x - p1.x) / (p2.y - p1.y);				mx1 = (p1.x + p2.x) * 0.5;				my1 = (p1.y + p2.y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (p3.x + p2.x) * 0.5;				yc = m1 * (xc - mx1) + my1;			}			else			{				m1 = -(p2.x - p1.x) / (p2.y - p1.y);				m2 = -(p3.x - p2.x) / (p3.y - p2.y);				mx1 = (p1.x + p2.x) * 0.5;				mx2 = (p2.x + p3.x) * 0.5;				my1 = (p1.y + p2.y) * 0.5;				my2 = (p2.y + p3.y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);				yc = m1 * (xc - mx1) + my1;			}			var dx:Number = p2.x - xc;			var dy:Number = p2.y - yc;			var rsqr:Number = dx * dx + dy * dy;			dx = p.x - xc;			dy = p.y - yc;			var drsqr:Number = dx * dx + dy * dy;			return ( drsqr <= rsqr );		}	}}